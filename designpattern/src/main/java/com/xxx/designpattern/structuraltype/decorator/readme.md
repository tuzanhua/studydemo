#装饰模式
 装饰模式降低了系统的耦合度,可以动态增加或删除对象的职责,并使得需要装饰的具体构件类和具体装饰类可以独立变化,以便增加
 新的具体构件类和具体装饰类.在软件开发中,装饰模式应用较为广泛,例如在JAVAIO 中的输入流和输出流的设计.

 优点
 1. 对于扩展一个对象的功能,装饰模式比继承更加灵活,不会导致累的个数急剧增加.
 2. 可以通过一种动态的方式来扩展一个对象的功能,通过配置文件可以运行时选择不同的具体装饰类
  从而实现不同的行为
 3. 可以对一个对象进行多次装饰,通过使用不同的具体装饰类以及这些装饰类的排列组合,可以创造出很多不同行为的组合,得到功能更为强大的对象.
 4. 具体构件类与具体装饰类可以独立变化,用户可以根据需要增加新的具体构件类和具体装饰类,原有类库代码无需改变,符合"开闭原则"

 缺点:
 1. 使用装饰模式进行系统设计时将产生很多小对象,这些对象的区别在于他们之间相互连接的方式有所不同,而不是他们的类或者属性值有所不同,大量小对象的产生势必会
 占用更多的系统资源,在一定程度上影响程序的性能
 2. 装饰模式提供了一种比继承更加灵活的解决方案,但是同时也意味着比继承更加容易出错,排错也很困难
 ,对于多次装饰的对象,调试时寻找错误可能需要逐级排查,较为繁琐


 适用场景:
   1. 在不影响其它对象的情况下,以动态透明的方式给单个对象添加职责
   2. 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式.
   不能采用继承的情况主要有两类: 第一类 是系统中存在大量独立的扩展,为支持每一种扩展或者扩展之间的组合
   将产生大量的子类,使得子类数目呈爆炸性增长;第二类是因为类已定义为不能被继承.
