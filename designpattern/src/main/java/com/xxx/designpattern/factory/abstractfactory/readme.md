# 抽象工厂模式:提供一个创建一系列相关或者相互依赖对象的接口,而无需指定他们具体的类.
抽象工厂模式:提供一个创建一系列相关或者相互依赖对象的接口,而无需指定它们具体的类.抽象工厂又称为kit模式
,它是一种对象创建型模式.

抽象工厂角色定义:
  1. AbstractFactory(抽象工厂) : 它声明了一组用于创建一族产品的方法,每一个方法对应一种产品.

  2. ConcreteFactory(具体工厂) : 它实现了在抽象工厂中声明的创建产品的方法,生成一组具体产品,这些产品构成了一个产品族,
  每一个产品都位于某个产品等级结构中.

  3. AbstractProduct(抽象产品) : 它为每种产品声明接口,在抽象产品中声明了产品所有的业务方法.

  4. ConcreteProduct(具体产品) : 它定义具体工厂生产的具体产品对象,是想抽象产品接口中声明的业务方法.

  思考 抽象工厂符合开闭原则吗?  从新增产品等级结构和新增产品族两个方面思考

  (产品的继承)等级结构不符合(这个说的是继承关系比说说一个抽象类是电视机子类是海尔 TCl 等)
  (工厂)产品族符合(这个说的是同一个工厂生产的 比如说海尔工厂生产海尔电视 冰箱空调等)



  ### 优点
  1. 抽象工厂隔离了具体类的生成,使得客户并不需要知道什么被创建. 由于这种隔离,更换一个具体的工厂就变得相对容易,
  所有具体工厂都实现了抽象工厂定义的那些公共接口,因此只需要改变具体工厂的实例,就可以在某种程度上改变整个软件系统
  的行为
  2. 当一个产品族中的多个对象被设计成一起工作时,它能够保证客户端始终只使用同一个产品族中的对象
  3. 增加新的产品族很方便,无需修改已有系统,符合"开闭原则"

  ###最大缺点: 增加产品族很简单 即新增 具体工厂 增加产品结构很困难 因为要修改 基类的产品定义所有实现都要修改 不符合开闭原则

  ####适用场景:
  1. 一个系统不应该依赖于产品类实例如何被创建.组合和表达的细节,这对于所有类型的工厂模式都很重要,用户无需关心对象的创建过程,将
  对象的创建和使用解耦
  2. 系统中有多于一个的产品族,而每次只使用其中某一产品族,可以通过配置文件等方式来使得用户可以动态改变产品族,也可以很方便的增加新的产品族
  3. 属于同一个产品族的产品将在一起使用,这一约束必须在系统的设计中体现出来.同一个产品族中的产品可以是没有任何关系的对象,但是他们都具有一些共同的约束
  ,如同一操作系统下的按钮和文本框,按钮与文本框之间没有直接关系,但它们都是属于某一个操作系统的,此时具有一个共同的约束条件:
  操作类型.
  4. 产品等级结构稳定,设计完之后,不会向系统中增加新的产品等级结构或者删除已有的产品等级结构.
